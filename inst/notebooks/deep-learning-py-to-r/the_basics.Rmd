---
title: "R-Python Basics with Numpy"
output: html_notebook
---

## The sigmoid function

```{r}
basic_sigmoid <- function(x) {
    s <- 1 / (1 + exp (-x))
    return(s)
}

```


```{r}
basic_sigmoid(3)
# 9525741
```

## Vector operations

```{r}
x <- array(c(1, 2, 3))
print(x + 3)
```


## Sigmoid on a vector

```{r}
sigmoid <- function(x) {
    s <- 1 / ( 1 + exp(-x))
    return(s)
}
```


```{r}
x <- array(c(1, 2, 3))
sigmoid(x)
```


## Sigmoid gradient

```{r}
sigmoid_derivative <- function(x) {
    # Compute the gradient (also called the slope or derivative) of the sigmoid 
    # function with respect to its input x.
    # You can store the output of the sigmoid function into variables and then 
    # use it to calculate the gradient.
    
    # Arguments:
    # x -- A scalar or numpy array
     
    # Return:
    # ds -- Your computed gradient.
    
    s <- 1 / ( 1 + exp(-x))
    ds <- s * (1 - s)
    return(ds)
}

```


```{r}
x <- array(c(1, 2, 3))
sigmoid_derivative(x)
# 0.19661193 0.10499359 0.04517666
```


## Reshaping arrays
, in computer science, an image is represented by a 3D array of shape (length,height,depth=3). However, when you read an image as the input of an algorithm you convert it to a vector of shape (length∗height∗3,1). In other words, you "unroll", or reshape, the 3D array into a 1D vector.


> Implement image2vector() that takes an input of shape (length, height, 3) and returns a vector of shape (length*height*3, 1). For example, if you would like to reshape an array v of shape (a, b, c) into a vector of shape (a*b,c) you would do.


Let's see in native Python and then convert it to a R array:

```{r}
library(reticulate)
np <- import("numpy", convert = FALSE)
(x.py.rm <- np$reshape(np$arange(1, 19), c(3L, 3L, 2L)))
```

This is the Python array we want to replicate using reticulate and R. It is a 3x3x2 array. Because it is Python generated, then it ordered `row-major`.

       [[[ 0.67826139,  0.29380381],
        [ 0.90714982,  0.52835647],
        [ 0.4215251 ,  0.45017551]],

       [[ 0.92814219,  0.96677647],
        [ 0.85304703,  0.52351845],
        [ 0.19981397,  0.27417313]],

       [[ 0.60659855,  0.00533165],
        [ 0.10820313,  0.49978937],
        [ 0.34144279,  0.94630077]]]

To enter this Python array to R, we should enter it as a vector, taking the rows first:

```{r}
vec_image <- c(0.67826139,  0.29380381, 
               0.90714982,  0.52835647, 
               0.4215251,   0.45017551, 
               0.92814219,  0.96677647, 
               0.85304703,  0.52351845, 
               0.19981397,  0.27417313, 
               0.60659855,  0.00533165,
               0.10820313,  0.49978937, 
               0.34144279,  0.94630077)
```



Let's try first what our instincts tell us; using R array function.

```{r}
image <- array(vec_image, dim = c(3, 3, 2))
r_to_py(image)
```

> We can see that this array does not resemble the target Python array above.
That is because, R builds its arrays as column-major.

## using a new function for row-major in R

```{r}
# This function will produce a row-major array for a vector
r_row_major <- function(x, dims) {
    X <- array(x, dim = rev(dims))
    aperm(X, perm = rev(1:length(dim(X))))
}

(image <- r_row_major(vec_image, c(3, 3, 2)) )
```

This was the R representation in row-major.

And now for the Python representation of the same array:

```{r}
(image_py <- r_to_py(image))
```

> Success! Now we have the desired Python array, in row-major format.

```{r}
dim(image)
# [1] 3 3 2
```




```{r}
# # on the first dimension, take the first position and jump to 2
np$take(image_py, 0L, 0L)
cat("\n")
np$take(image, 2L, 0L)
```

This is the same as doing this in R:

```{r}
identical(
    py_to_r(np$take(image_py, 0L, 0L)),
    image[1,,]
)    
[1] TRUE
```

These are the representations:

```{r}
py_to_r(np$take(image_py, 0L, 0L))
image[1,,]
```

```{r}
identical(
    py_to_r(np$take(image, 2L, 0L)),
    image[3,,]
)
# [1] TRUE
```

These are the representations:

```{r}
py_to_r(np$take(image, 2L, 0L))
image[3,,]
```

## Convert image to vector



```{r}
image2vector <- function(image){
    # Argument:
    # image -- a numpy array of shape (length, height, depth)
    # 
    # Returns:
    # v -- a vector of shape (length*height*depth, 1)
    
    array(image, dim = c(dim(image)[1] * dim(image)[2] * dim(image)[3], 1))
}    
```

```{r}
r_to_py(image2vector(image))
```

```{r}
image
```

    r_row_major <- function(x, dims) {
        X <- array(x, dim = rev(dims))
        aperm(X, perm = rev(1:length(dim(X))))
    }

```{r}
row_major_to_vector <- function(a) {
    arr <- aperm(a, perm = rev(1:length(dim(a))))
    arr <- array(arr, dim = rev(dim(arr)))
    # this function not fully automatic because it only works for 3-D arrays
    array(arr, dim = c(dim(arr)[1] * dim(arr)[2] * dim(arr)[3], 1))
}

row_major_to_vector(image)
```

    [[ 0.67826139] [ 0.29380381] [ 0.90714982] [ 0.52835647] [ 0.4215251 ] [ 0.45017551] [ 0.92814219] [ 0.96677647] [ 0.85304703] [ 0.52351845] [ 0.19981397] [ 0.27417313] [ 0.60659855] [ 0.00533165] [ 0.10820313] [ 0.49978937] [ 0.34144279] [ 0.94630077]]


```{r}
# build a function to multiply any dimensions
# dim = c(dim(arr)[1] * dim(arr)[2] * dim(arr)[3]

dim(image)
length(dim(image))

# convert this `for` loop to apply family
m <- 1
for (i in rev(1:3)) {
    m <- as.integer(dim(image)[i] * m)
}
m
```

```{r}
identical(
    m,
    length(sapply(image, dim))
)
```

```{r}
# new row_major_to_vector
row_major_to_vector <- function(a) {
    arr <- aperm(a, perm = rev(1:length(dim(a))))
    arr <- array(arr, dim = rev(dim(arr)))
    as.vector(array(arr, dim = c(length(sapply(image, dim)), 1)))   
    # now this works for any n-d array
}

row_major_to_vector(image)
```

```{r}
# verify that the resulting vector is the same as the original vector
identical(
    row_major_to_vector(image), vec_image
)
```

This is the same problem but using pure Python.

```{python}
import numpy as np
# GRADED FUNCTION: image2vector
def image2vector(image):
    """
    Argument:
    image -- a numpy array of shape (length, height, depth)
    
    Returns:
    v -- a vector of shape (length*height*depth, 1)
    """
    
    v = image.reshape((image.shape[0] * image.shape[1] * image.shape[2], 1))
    
    return v

image = np.array([
       [[ 0.67826139,  0.29380381],
        [ 0.90714982,  0.52835647],
        [ 0.4215251 ,  0.45017551]],

       [[ 0.92814219,  0.96677647],
        [ 0.85304703,  0.52351845],
        [ 0.19981397,  0.27417313]],

       [[ 0.60659855,  0.00533165],
        [ 0.10820313,  0.49978937],
        [ 0.34144279,  0.94630077]]])

print ("image2vector(image) = " + "\n" + str(image2vector(image)))    


```

> So, finally we are confirming that both image to vector conversion, in Python and R, are the same.

## Normalizing rows
This technique leads to a better performance because gradient descent converges faster after normalization.

> **Exercise**: Implement normalizeRows() to normalize the rows of a matrix. After applying this function to an input matrix x, each row of x should be a vector of unit length (meaning length 1).

```{python}
import numpy as np

def normalizeRows(x):
    """
    Implement a function that normalizes each row of the matrix x (to have unit length).
    
    Argument:
    x -- A numpy matrix of shape (n, m)
    
    Returns:
    x -- The normalized (by row) numpy matrix. You are allowed to modify x.
    """
    
    # Compute x_norm as the norm 2 of x. 
    # Use np.linalg.norm(..., ord = 2, axis = ..., keepdims = True)
    x_norm = np.linalg.norm(x, axis=1, keepdims=True)
    #print(x_norm)
    #print("x_norm.shape:", x_norm.shape, "\n")
    
    # Divide x by its norm.
    x = x / x_norm
    ### END CODE HERE ###

    return x
    
x = np.array([
    [0, 3, 4],
    [1, 6, 4]])

print(x.shape)
print("normalizeRows(x) = \n" + str(normalizeRows(x)))  
```

> Expected output:

```{text}
normalizeRows(x) = 
[[ 0.          0.6         0.8       ]
 [ 0.13736056  0.82416338  0.54944226]]
```


Now, using R:


```{r}
v <- c(0, 1, 3, 6, 4, 4)
reticulate::r_to_py(array(v, c(2, 3)))

```

The array 2x3 looks exactly the same as in Python.
But we have to be careful, because this order won't work above 2-D dimension.

```{r}
normalizeRows <- function(x) {
    x_norm <-  norm(x, "F")
    x <- x / x_norm
    return(x)
}

v <- c(0, 1, 3, 6, 4, 4)
a <- r_row_major(v, c(2, 3))
normalizeRows(a)
```

