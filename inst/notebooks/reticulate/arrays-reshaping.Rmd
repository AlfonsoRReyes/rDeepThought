---
title: "Reshaping arrays"
output: html_notebook
---

```{r}
library(reticulate)
np <- import("numpy", convert=FALSE)

```

In R you would typically reshape an array using the dim<-() function. For example:

```{r}
x <- 1:(1000*28*28)
dim(x) <- c(1000, 28, 28)
dim(x)
rs <- apply(x, 1, rowSums)
mean(rs)
```

In R, this operation simply changes the `dim` attribute of the array, effectively re-interpreting the array indices as specified using column-major semantics.

However, the NumPy `reshape` method uses row-major semantics by default, so if you are mixing R and Python code that reshapes arrays you will find that the reshaping will be inconsistent if you use the R dim<-() function.

To overcome this inconsistency, there is an `array_reshape()` function which will reshape an R array using row-major semantics (i.e. will fill the new dimensions in row-major rather than col-major order). The example above would be re-written as:

```{r}
x <- array_reshape(x, c(1000, 28, 28))
dim(x)
rs <- apply(x, 1, rowSums)
mean(rs)
```


```{r}
# let's construct a 2x2 array from a vector of 4 elements
x <- 1:4

# rearrange will fill the array row-wise
array_reshape(x, c(2, 2))
#      [,1] [,2]
# [1,]    1    2
# [2,]    3    4

# setting the dimensions 'fills' the array col-wise
dim(x) <- c(2, 2)
x
#      [,1] [,2]
# [1,]    1    3
# [2,]    2    4
```

It’s easy to be confused by this, so let’s see an example using a 4x3x2 array, first in Python:

```{r}
library(reticulate)
np <- import("numpy", convert=FALSE)
x  <- np$arange(1, 25)$reshape(c(4L, 3L, 2L))
x$sum(0L)   # N. B. a 3x2 matrix!

## [[ 40.  44.]
##  [ 48.  52.]
##  [ 56.  60.]]

# N. B. A tuple() object is required here (NumPy vectors won't work)
x$sum(tuple(1L, 2L))

## [  21.   57.   93.  129.]
```

And now the corresponding sums in R:


```{r}
y <- py_to_r(x)
apply(y, dim(y)[-1], sum)

##      [,1] [,2] [,3]
## [1,]   40   48   56
## [2,]   44   52   60

apply(y, 1, sum)

## [1]  21  57  93 129
```


## Addressing an issue that came up
These notes were prepared in response to a tensorflow issue now in the reticulate package https://github.com/rstudio/reticulate/issues/9. The issue directly gets to a common source of confusion with n-d arrays in R and Python and how they are printed and stored. A lightly-edited reproduction of the reference Python code in the issue appears below.

```{r}
library(reticulate)
use_condaenv("r-tensorflow")
py_config()
```

### Matrix multiplications using Python arrays

```{r results='hold'}
library(tensorflow)

np   <- import("numpy", convert=FALSE)
a    <- np$arange(1, 9)$reshape(c(2L, 2L, 2L))
b    <- np$arange(1, 5)$reshape(c(2L, 2L, 1L))
c    <- tf$matmul(tf$constant(a), tf$constant(b))
tf$Session()$run(c)

## , , 1
##      [,1] [,2]
## [1,]    5   11
## [2,]   39   53
```

The issue goes on to reproduce the example using R-generated arrays as follows:

```{r}
A <- list(matrix(1:4, nrow=2, byrow=T), matrix(5:8, nrow=2, byrow=T))
(A <- array(unlist(A), dim=c(2,2,2)))
(B <- array(1:4, c(2,2,2)))
```

However, already at this point we see that the R-generated array A is not the same as the above array a by comparing a with np$array(A) below.

However, we can see how it can be easy to make the mistake that they are the same simply because of the way the arrays are printed! The R array looks superficially the same as the printed Python array.

```{r}
print(a)

## [[[ 1.  2.]
##   [ 3.  4.]]
## 
##  [[ 5.  6.]
##   [ 7.  8.]]]


print(np$array(A))

## [[[1 5]
##   [2 6]]
## 
##  [[3 7]
##   [4 8]]]


print(A)

## , , 1
##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
## 
## , , 2
##      [,1] [,2]
## [1,]    5    6
## [2,]    7    8
```

Instead, we need to construct the R array A differently to match the row-major order of Python, discussed in the previous sections. We can use many approaches including:

```{r}
(A <- aperm(array(1:8, c(2,2,2)), c(3,2,1)))    # row-major
(A <- np$array(A))

## [[[1 2]
##   [3 4]]
## 
##  [[5 6]
##   [7 8]]]
```

### Matrix multiplication using R generated arrays

With similar care ordering the values in the b array we can finish replicating the example in R (with the same result as the reference Python example above).

```{r}
A <- np$array(aperm(array(1:8, c(2,2,2)), c(3,2,1)))
B <- np$array(aperm(array(1:4, c(2,2,1)), c(2,1,3)))
C <- tf$matmul(tf$constant(A), tf$constant(B))
tf$Session()$run(C)
```

