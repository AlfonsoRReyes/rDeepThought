---
title: "R Notebook"
output: html_notebook
---


```{r}
# raw array
raw_image <- cbind(
    rbind(
        c( 0.67826139,  0.29380381),
        c( 0.90714982,  0.52835647),
        c( 0.4215251 ,  0.45017551)),

       rbind(
        c( 0.92814219,  0.96677647),
        c( 0.85304703,  0.52351845),
        c( 0.19981397,  0.27417313)),

       rbind(
        c( 0.60659855,  0.00533165),
        c( 0.10820313,  0.49978937),
        c( 0.34144279,  0.94630077)))

raw_image
```





> 

```{r}
vec_image <- c(0.67826139, 0.29380381, 0.90714982, 0.52835647, 0.4215251, 0.45017551, 0.92814219,  0.96677647, 0.85304703,  0.52351845, 0.19981397,  0.27417313, 0.60659855,  0.00533165,
        0.10820313,  0.49978937, 0.34144279,  0.94630077           
               )
```


```{r}

image =  array(cbind(
    rbind(
        c( 0.67826139,  0.29380381),
        c( 0.90714982,  0.52835647),
        c( 0.4215251 ,  0.45017551)),

       rbind(
        c( 0.92814219,  0.96677647),
        c( 0.85304703,  0.52351845),
        c( 0.19981397,  0.27417313)),

       rbind(
        c( 0.60659855,  0.00533165),
        c( 0.10820313,  0.49978937),
        c( 0.34144279,  0.94630077))),
    dim = c(3,3,2)
)

image

```





```{r}
# take row 1 only
image[1,,]
```

```{r}
# take column 2
image[,2,]
```


```{r}
# take slice 2
image[,,2]
```



```{r}
# This is another way of creating the R array as row-major
aperm(array(1:25, dim = c(2, 3, 4)), c(3, 2, 1))
```

```{r}
identical(
    aperm(array(matrix(1:24, c(3 * 4, 2), byrow = TRUE), 
                dim = c(3, 4, 2)), c(2, 1, 3)), 
    aperm(array(1:25, dim = c(2, 3, 4)), c(3, 2, 1))
)
```

```{r}
# decomposing all terms. using rev() function
x <- 1:24
nr <- 4; nc <- 3; ns <- 2
( X.rm <- aperm(array(x, dim = c(ns, nc, nr)), perm = rev(1:length(dim(X.rm)))) )

```


> since the way the array is constructed doesn't have much sense, let's build a function:

```{r}
# 1st iteration of r_row_major
r_row_major_1 <- function(x, dims) {
    aperm(array(x, dim = c(dims[3], dims[2], dims[1])), c(3, 2, 1))
}

r_row_major_1(1:25, c(4,3,2))
```


```{r}
# 2nd iteration of r_row_major
# This time we replace the explicit and manual make up of the perm vector
r_row_major_2 <- function(x, dims) {
    aperm(array(x, dim = c(dims[3], dims[2], dims[1])), 
          perm = rev(1:length(dim(X.rm))))
}


r_row_major_2(1:25, c(4,3,2))
```

```{r}
# 3rd iteration of r_row_major
# 
r_row_major_3 <- function(x, dims) {
    X <- array(x, dim = rev(dims))
    aperm(X, perm = rev(1:length(dim(X))))
}


r_row_major_3(1:25, c(4, 3, 2))
```

> Testing if r_row_major_3() works for 2-D:

```{r}
r_row_major_3 <- function(x, dims) {
    X <- array(x, dim = rev(dims))
    aperm(X, perm = rev(1:length(dim(X))))
}

np <- reticulate::import("numpy", convert = FALSE)
op <- reticulate::import("operator")

reticulate::r_to_py(r_row_major_3(1:25, c(4, 3 * 2)))
np$reshape(np$arange(1, 25), c(4L, 3L * 2L))

# these two expresions are identical
op$sub(reticulate::r_to_py(r_row_major_3(1:25, c(4, 3 * 2))),
       np$reshape(np$arange(1, 25), c(4L, 3L * 2L))
)
```

3-D

```{r}
r_row_major_3 <- function(x, dims) {
    X <- array(x, dim = rev(dims))
    aperm(X, perm = rev(1:length(dim(X))))
}

np <- reticulate::import("numpy", convert = FALSE)
op <- reticulate::import("operator")

reticulate::r_to_py(r_row_major_3(1:25, c(4, 3, 2)))
np$reshape(np$arange(1, 25), c(4L, 3L, 2L))

# these two expresions are identical
op$sub(reticulate::r_to_py(r_row_major_3(1:25, c(4, 3, 2))),
       np$reshape(np$arange(1, 25), c(4L, 3L, 2L))
)
```

> 4-D

```{r}
r_row_major_3 <- function(x, dims) {
    X <- array(x, dim = rev(dims))
    aperm(X, perm = rev(1:length(dim(X))))
}

np <- reticulate::import("numpy", convert = FALSE)
op <- reticulate::import("operator")

reticulate::r_to_py(r_row_major_3(1:25, c(4, 3, 2, 1)))
np$reshape(np$arange(1, 25), c(4L, 3L, 2L, 1L))

# these two expresions are identical
op$sub(reticulate::r_to_py(r_row_major_3(1:25, c(4, 3, 2, 1))),
       np$reshape(np$arange(1, 25), c(4L, 3L, 2L, 1L))
)
```


> 5-D

```{r}
np <- reticulate::import("numpy", convert = FALSE)
op <- reticulate::import("operator")

r_row_major <- function(x, dims) {
    X <- array(x, dim = rev(dims))
    aperm(X, perm = rev(1:length(dim(X))))
}

# using np$reshape(np$arange(1, 121), c(5L, 4L, 3L, 2L, 1L))
identical(
    array(0, c(5,4,3,2,1)),   # 5-D array of zeros
    op$sub(
        reticulate::r_to_py(r_row_major(1:121, c(5, 4, 3, 2, 1))), 
        np$reshape(np$arange(1, 121), c(5L, 4L, 3L, 2L, 1L))
    )
)
# [1] TRUE

# using np$arange(1, 121)$reshape(5L, 4L, 3L, 2L, 1L)
identical(
    array(0, c(5,4,3,2,1)),   # 5-D array of zeros
    op$sub(
        reticulate::r_to_py(r_row_major(1:121, c(5, 4, 3, 2, 1))), 
        np$arange(1, 121)$reshape(5L, 4L, 3L, 2L, 1L)
    )
)
# [1] TRUE

```

```{r}
r_row_major <- function(x, dims) {
    X <- array(x, dim = rev(dims))
    aperm(X, perm = rev(1:length(dim(X))))
}

array(1:25, c(4, 3, 2))        # column-major
r_row_major(1:25, c(4, 3, 2))  # row-major
```








```{r}
r_to_py(r_row_major(1:25, c(4,3,2)))
```


```{r}
o <- import("operator")
o$sub(x.py.rm, r_to_py(r_row_major(1:25, c(4,3,2))))
```


> This is another way to demonstrate row-major from R to Python, but it makes no sense from the the way it has been built in Python:
    
    np$reshape(np$arange(1, 25), c(4L, 3L, 2L))

```{r}
(r_to_py <- np$array(aperm(array(1:25, c(2,3,4)), c(3,2,1))))
```

> If these arrays are identical, the restult should be zero:

```{r}
o <- import("operator")
o$sub(x.py.rm, r_to_py)
```





