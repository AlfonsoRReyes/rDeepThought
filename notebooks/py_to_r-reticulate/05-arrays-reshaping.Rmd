---
title: "Reshaping arrays"
output: html_notebook
---

```{r}
library(reticulate)
np <- import("numpy", convert=FALSE)

```

In R you would typically reshape an array using the dim<-() function. For example:

```{r}
x <- 1:(1000*28*28)
dim(x) <- c(1000, 28, 28)
dim(x)
rs <- apply(x, 1, rowSums)
mean(rs)
```

In R, this operation simply changes the `dim` attribute of the array, effectively re-interpreting the array indices as specified using **column-major** semantics.

However, the NumPy `reshape` method uses **row-major** semantics by default, so if you are mixing R and Python code that reshapes arrays you will find that the reshaping will be inconsistent if you use the R dim<-() function.

To overcome this inconsistency, there is an `array_reshape()` function which will reshape an R array using `row-major` semantics (i.e. will fill the new dimensions in `row-major` rather than `col-major` order). The example above would be re-written as:

```{r}
x <- array_reshape(x, c(1000, 28, 28))
dim(x)
rs <- apply(x, 1, rowSums)
mean(rs)
```


```{r}
# let's construct a 2x2 array from a vector of 4 elements
x <- 1:4

# rearrange will fill the array row-wise
array_reshape(x, c(2, 2))
#      [,1] [,2]
# [1,]    1    2
# [2,]    3    4

# setting the dimensions 'fills' the array col-wise
dim(x) <- c(2, 2)
x
#      [,1] [,2]
# [1,]    1    3
# [2,]    2    4
```

It’s easy to be confused by this, so let’s see an example using a 4x3x2 array, first in Python:

```{r}
library(reticulate)
np <- import("numpy", convert=FALSE)
x  <- np$arange(1, 25)$reshape(c(4L, 3L, 2L))
x$sum(0L)   # N. B. a 3x2 matrix!

## [[ 40.  44.]
##  [ 48.  52.]
##  [ 56.  60.]]

# N. B. A tuple() object is required here (NumPy vectors won't work)
x$sum(tuple(1L, 2L))

## [  21.   57.   93.  129.]
```

And now the corresponding sums in R:


```{r}
y <- py_to_r(x)
apply(y, dim(y)[-1], sum)

##      [,1] [,2] [,3]
## [1,]   40   48   56
## [2,]   44   52   60

apply(y, 1, sum)

## [1]  21  57  93 129
```


## Addressing an issue that came up
These notes were prepared in response to a tensorflow issue now in the reticulate package https://github.com/rstudio/reticulate/issues/9. The issue directly gets to a common source of confusion with n-d arrays in R and Python and how they are printed and stored. A lightly-edited reproduction of the reference Python code in the issue appears below.

```{r}
library(reticulate)
use_condaenv("r-tensorflow")
py_config()
```

### Matrix multiplications using Python arrays

```{r results='hold'}
library(tensorflow)

np   <- import("numpy", convert=FALSE)
a    <- np$arange(1, 9)$reshape(c(2L, 2L, 2L))
b    <- np$arange(1, 5)$reshape(c(2L, 2L, 1L))
c    <- tf$matmul(tf$constant(a), tf$constant(b))
tf$Session()$run(c)

## , , 1
##      [,1] [,2]
## [1,]    5   11
## [2,]   39   53
```

The issue goes on to reproduce the example using R-generated arrays as follows:

```{r}
A <- list(matrix(1:4, nrow=2, byrow=T), matrix(5:8, nrow=2, byrow=T))
(A <- array(unlist(A), dim=c(2,2,2)))

## , , 1
##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
## 
## , , 2
##      [,1] [,2]
## [1,]    5    6
## [2,]    7    8

# (B <- array(1:4, c(2,2,2)))
```

However, already at this point we see that the R-generated array A is not the same as the above array a by comparing a with np$array(A) below.

```{r}
print(a)

## [[[ 1.  2.]
##   [ 3.  4.]]
## 
##  [[ 5.  6.]
##   [ 7.  8.]]]


print(np$array(A))     # convert the R array to Python

## [[[1 5]
##   [2 6]]
## 
##  [[3 7]
##   [4 8]]]
```

However, we can see how it can be easy to make the mistake that they are the same simply because of the way the arrays are printed! The R array looks superficially the same as the printed Python array.

Instead, we need to construct the R array A differently to match the `row-major` order of Python, discussed in the previous sections. We can use many approaches including:

```{r}
# combination of array and aperm
(A <- aperm(array(1:8, c(2,2,2)), c(3,2,1)))    # row-major
(A <- np$array(A))

## [[[1 2]
##   [3 4]]
## 
##  [[5 6]
##   [7 8]]]
```

```{r}
# using reticulate::array_reshape
( A <- array_reshape(1:8, c(2,2,2), order = "C") )
```


### Matrix multiplication using R generated arrays

With similar care ordering the values in the b array we can finish replicating the example in R (with the same result as the reference Python example above).

```{r}
# Multiplication in Python
Ap <- np$array(aperm(array(1:8, c(2,2,2)), c(3,2,1)))
Bp <- np$array(aperm(array(1:4, c(2,2,1)), c(2,1,3)))
Ap$shape
Bp$shape
Cp <- tf$matmul(tf$constant(Ap), tf$constant(Bp))
tf$Session()$run(Cp)
py_to_r(np$matmul(Ap, Bp))
```

```{r}
cat("Ap\n"); py_to_r(Ap)
cat("Bp\n"); py_to_r(Bp)
```


```{r}
# Multiplication in R
Ar <- array_reshape(1:8, c(2,2,2), order = "C")
Br <- array_reshape(1:4, c(2,2,1), order = "C")
Ar
Br
# ( Cr <- crossprod(Ar , Br) )
Ar %*% Br
```

```{r}
# Ar %*% 
# Ar %*% aperm(array(Br, c(2,2,2)), c(2,3,1)) 
Ar %*% array(matrix(1:4, nrow = 1, ncol = 4, byrow = TRUE), dim = c(1,4))

# This is not what we are looking for

#     [,1] [,2] [,3] [,4]
# [1,]    1    2    3    4
# [2,]    5   10   15   20
# [3,]    3    6    9   12
# [4,]    7   14   21   28
# [5,]    2    4    6    8
# [6,]    6   12   18   24
# [7,]    4    8   12   16
# [8,]    8   16   24   32
```

```{r}
Ar %*% aperm(array(1:4, c(4,2,1)), c(1,2,3))
```


R cannot do broadcasting as in Python. So, we use Python `matmul` function.

```{r}
# numpy matmul
py_to_r(np$matmul(Ar, Br))
```


```{r}
Cr <- tf$matmul(tf$constant(Ar), tf$constant(Br))
tf$Session()$run(Cr)
```

# Another example

```{python}
import tensorflow as tf
# 2-D tensor `a`
# [[1, 2, 3],
#  [4, 5, 6]]
a = tf.constant([1, 2, 3, 4, 5, 6], shape=[2, 3])

# 2-D tensor `b`
# [[ 7,  8],
#  [ 9, 10],
#  [11, 12]]
b = tf.constant([7, 8, 9, 10, 11, 12], shape=[3, 2])

# `a` * `b`
# [[ 58,  64],
#  [139, 154]]
c = tf.matmul(a, b)
cc = tf.Session().run(c)
print(cc)
```

```{r}
library(reticulate)
py$cc
```

```{r}
ar <- array_reshape(1:6, c(2,3), order = "C")
br <- array_reshape(7:12, c(3,2), order = "C")
ar
br
ar %*% br
```

