---
title: "Arrays in R and Python"
output: html_notebook
---

https://cran.r-project.org/web/packages/reticulate/vignettes/arrays.html


## Column-major order
Column-major order is used by Fortran, Matlab, R, and most underlying core linear algebra libraries (BLAS). Sequential address locations are translated into array coordinates $i, j, k, ...$ so that the **first array coordinates vary most rapidly with address**, the next array coordinates less rapidly, and so on. For instance, four address locations 1, 2, 3, 4 are translated into a two by two matrix coordinate system $(i, j)$ as:

```{text}
address   i  j
  1       1  1
  2       2  1
  3       1  2
  4       2  2
```

The phrase column-major comes from the matrix example, where sequentially addressed data are laid out sequentially along columns of the matrix.

The concept of "row" and "column" don't directly apply to `n-d` arrays, but the same idea holds. For instance the R language lays out sequential addresses from 1, 2, ..., 8, into a `2x2x2` 3-d array as:

```{text}
address   i  j  k
  1       1  1  1
  2       2  1  1
  3       1  2  1
  4       2  2  1
  5       1  1  2
  6       2  1  2
  7       1  2  2
  8       2  2  2
```

In the example above, the dimension `k` changes the slowest, then `j`, and `i` changes the fastest.

## Row-major order
Row-major ordering is a different translation between sequential address indices and array coordinates, instead laying sequential data in memory across rows in matrices. Row-major ordering is sometimes called “C” style ordering and column-major ordering “Fortran” style. Python/NumPy refers to the orderings in array flags as C_CONTIGUOUS and F_CONTIGUOUS, respectively. For instance address locations 1, 2, 3, 4 are translated into a 2x2 matrix coordinate system (i, j) as:

```{text}
address   i  j
  1       1  1
  2       1  2
  3       2  1
  4       2  2
```  

Efficient wrappers to BLAS routines exist for row-major ordered arrays. For completeness, here is a 2x2x2 3-d example layout:

```{text}
address   i  j  k
  1       1  1  1
  2       1  1  2
  3       1  2  1
  4       1  2  2
  5       2  1  1
  6       2  1  2
  7       2  2  1
  8       2  2  2
```

And similarly to above a formula for this example that converts these 1-based array coordinates to address indices is: 
a = k + (j - 1) * d3 + (i - 1) * d3 * d2.

See the following notes for a general formula for row- and column-order coordinate to address mapping, but note the use of zero-based indexing.

https://en.wikipedia.org/wiki/Row-_and_column-major_order#Address_calculation_in_general
https://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html

## Arrays in R
R displays array data with unambiguously-labeled coordinate indices. 

```{r}
array(1:24, c(4,3,2))
```

Python doesn't show this and displays $n$-d array data in different order than R (making matters somewhat confusing for R users). Consider the following example that creates and displays identical `4x3x2` arrays in R and Python:

```{r}
# run this firsrt to check Python is installed
reticulate::py_config()
```

```{r}
# load pytorch
library(reticulate)
use_condaenv("pytorch")
py_config()
```

Here is a Python script using the knitr engine:

>  Note. The ‘F’ at the end of the `reshape` function means to read / write the elements using `Fortran`-like index order, with the first index changing fastest, and the last index changing slowest. 


```{python}
import numpy as np
xpy = np.reshape(np.arange(1, 25), (4, 3, 2), "F") 
print(xpy)   # "F"" means like-Fortran
```

> This array should be the same as the one we just generated above in R.
But they don't look the same. Let's visualize the Python array as an R array.
Unfortunately we cannot transfer Python values to R values inside the notebook.
We have to use the package `reticulate`.

It's easier to know which coordinates go where in R because they are labeled.

Python, using column-major ordering, displays the same thing but in a different order where the first indices are grouped together in order. To see that these arrays are, in fact, the same, let's pick out values along just the first "row", that is values with a first index of 1 (R) or 0 (Python):


And this same example using `reticulate`:
```{r}
library(reticulate)
np <- import("numpy", convert=FALSE)
# np$arange(1,25)$reshape(4L, 3L, 2L)
np$reshape(np$arange(1, 25), c(4L, 3L, 2L))
```


```{r}
library(reticulate)
np <- import("numpy", convert=FALSE)
(x <- np$arange(1, 9)$reshape(2L, 2L, 2L))

(y <- py_to_r(x))
```

```{r}
y[1,,, drop=FALSE]
```



## Reticulate with care

Point number 3. introduces the most potential confusion. Let's look at some examples to explore these points.

The following example creates a `2x2x2` array in Python using native NumPy row-major ordering and imports it into R. Despite the fact that they print out differently, they are in fact the same.

```{r}
library(reticulate)
print("Python array")
np <- import("numpy", convert=FALSE)
(x <- np$arange(1, 9)$reshape(2L, 2L, 2L))

## [[[ 1.  2.]
##   [ 3.  4.]]
## 
##  [[ 5.  6.]
##   [ 7.  8.]]]

cat("\n R array converted from Python\n")
(y <- py_to_r(x))

## , , 1
##      [,1] [,2]
## [1,]    1    3
## [2,]    5    7
## 
## , , 2
##      [,1] [,2]
## [1,]    2    4
## [2,]    6    8
```

Wait a minute! They look different! But remember Python's print order is different. The first "rows" (first index values) are grouped together. Let's pull out elements with first index of 1 in the R result, with and without dropping the unused dimension to show precisely what we're indexing here:

```{r}
cat("\nArray without dropping the original frame\n")
y[1,,, drop=FALSE]

## , , 1
##      [,1] [,2]
## [1,]    1    3
## 
## , , 2
##      [,1] [,2]
## [1,]    2    4

cat("\nArray dropping the original frame\n")
y[1,,, drop=TRUE]

##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
```

Note that this is the same as the first block printed in the Python output! These arrays really are the same in Python and R, respectively. Their apparent differences are merely a result of printing.

    [1] "Python array"
    [[[ 1.  2.]        <- values in first dimension
      [ 3.  4.]]
    
     [[ 5.  6.]
      [ 7.  8.]]]


Now, printing the 2nd index of the first dimension:

```{r}
cat("\nArray maintaining the original frame\n")
y[2,,, drop=FALSE]

## , , 1
##      [,1] [,2]
## [1,]    1    3
## 
## , , 2
##      [,1] [,2]
## [1,]    2    4

cat("\nArray dropping the original frame\n")
y[2,,, drop=TRUE]

##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
```

Finally, to obtain the exact Python representation:
```{r}
# [1] "Python array"
# [[[ 1.  2.]
#   [ 3.  4.]]
# 
#  [[ 5.  6.]
#   [ 7.  8.]]]

y[1,,, drop=TRUE]
y[2,,, drop=TRUE]
```

Now, how do we obtain an exact Python representation if we use the knitr engine:

```{python}
import numpy as np
print np.reshape(np.arange(1, 9), (2, 2, 2), "F")   # "F"" means like-Fortran
```

> Why doesn't look the same as the Python-R representation above?

For instance, this is taken directly from Python:

    >>> import numpy as np
    >>> print np.reshape(np.arange(1, 9), (2, 2, 2), "F")
    [[[1 5]
      [3 7]]
    
     [[2 6]
      [4 8]]]
    >>>

```{r}
library(reticulate)
print("Python array")
np <- import("numpy", convert = TRUE)
# (x <- np$arange(1, 9)$reshape(2L, 2L, 2L))
v <- np$arange(1, 9)

# v$reshape((2, 2, 2))
# np$arange(1, 9)$reshape(2, 2, 2)
np$reshape(v, c(2L,2L,2L), "C")
np$reshape(v, c(2L,2L,2L), "F")
```


## Another example
Let's look at this again with another example, this time with an array with different lengths along each dimension to make things even more clear (hopefully). 

Consider the following `4x3x2` array constructed in Python in row-major order:

```{r}
np <- import("numpy", convert=FALSE)
(x <- np$reshape(np$arange(1, 25), c(4L, 3L, 2L)))
## [[[  1.   2.]
##   [  3.   4.]
##   [  5.   6.]]
## 
##  [[  7.   8.]
##   [  9.  10.]
##   [ 11.  12.]]
## 
##  [[ 13.  14.]
##   [ 15.  16.]
##   [ 17.  18.]]
## 
##  [[ 19.  20.]
##   [ 21.  22.]
##   [ 23.  24.]]]

(y <- py_to_r(x))        # converting from Python to R

## , , 1
##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    7    9   11
## [3,]   13   15   17
## [4,]   19   21   23
## 
## , , 2
##      [,1] [,2] [,3]
## [1,]    2    4    6
## [2,]    8   10   12
## [3,]   14   16   18
## [4,]   20   22   24

```

Again, they look quite different but the R and Python arrays are really the same. Let's pick out the sub-array when the third index (`2L`) is equal to 0 (Python indexing base), equivalently the third index (`3`, or third position in the array) when takes the value of `1` in R.

```{r}
# in Python the first index is zero
np$take(x, 0L, 2L)       #  take(array, index, dimension)

## [[  1.   3.   5.]
##  [  7.   9.  11.]
##  [ 13.  15.  17.]
##  [ 19.  21.  23.]]

# in R, the first index is one
y[, , 1]                 # array[1st_dim, 2nd_dim, 3rd_dim]

##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    7    9   11
## [3,]   13   15   17
## [4,]   19   21   23
```


The NumPy `take()` function is equivalent in this example to the Python notation `x[:, :, 0]`:

```{python}
import numpy as np
xp = np.reshape(np.arange(1, 25), (4, 3, 2))
print xp[:,:, 0]
```

that is, entries with third dimension index = 0. (See https://docs.scipy.org/doc/numpy/reference/generated/numpy.take.html.)

The corresponding R notation, y[, , 1], returns the same thing in this example: a 4x3 matrix.

Despite different internal memory ordering, and particularly despite awkward differences in printing arrays, the arrays are the same and are indexed the same way in each language respectively.


## Working on row-major, or C-like, order
> How do we know these two arrays are the same?

We build a R arrays that is ordered using row-major:

```{r}
# row-major order in R
y.rm <- aperm(array(matrix(1:24, c(3 * 4, 2), byrow=TRUE),
           c(3, 4, 2)), c(2, 1, 3))
y.rm
```

And convert the R array to Python:

```{r}
# Converting the R array to Python
y.rm.py <- np$array(y.rm)
y.rm.py
```


Now, the following array follows the default order in Python, row-major, or C-like.

```{r}
y.py <- np$arange(1, 25)$reshape(4L, 3L, 2L)  # note that defult order is "C"
y.py
```

Let's confirm that the array is ordered C-like, or row-major:

```{r}
y.py$flags
```

`C_CONTIGUOUS : True`, means the arrays is ordered as C-like.

Subtract, the two arrays that were ordered as row-major.

```{r}
# load the package operator
op <- import("operator", convert = FALSE)

op$sub(y.py, y.rm.py)   # subtraction of two arrays
```

> This is the est way to test if the Python array is identical to R converted array: by subtracting both. If it yields an array of zeros, both are identical.


## Inverse process with column-major
We can prove this using column-major order:

```{r}
library(reticulate)

np <- import("numpy", convert=FALSE)
op <- import("operator", convert = FALSE)

(x.py <- np$reshape(np$arange(1, 25), c(4L, 3L, 2L), "F"))  # "F" is column-major
```


```{r}
# we build an array in R
(y.r <- array(1:25, c(4,3,2)))   # of course, this is column-major; it's R
```

```{r}
# convert the R array to Python array
(y.py <- np$array(y.r))
```

```{r}
y.py$flags
```

`F_CONTIGUOUS : True` is Fortran-like, or column-major.


```{r}
# subtract the Python array from the R converted array
op$sub(y.py, x.py)
```

That's it. This is the inverse process of the example on row-major above.


```{css}
h2 {
  color: blue;
  text-decoration: underline;
}

h1 {
  color: brown;
  text-align: center;
  text-shadow: 3px 2px gray;
}
```
