---
title: "Arrays in row-major order"
output: html_notebook
---

> Python by default creates arrays in row-major order


```{r}
library(reticulate)
np <- import("numpy", convert = FALSE)
# np$arange(1,25)$reshape(4L, 3L, 2L)
(x.py.rm <- np$reshape(np$arange(1, 25), c(4L, 3L, 2L)))
```

> these two expressions are equivalent (both are ordered row-major:

```{text}
    py_to_r(np$reshape(np$arange(1, 25), c(4L, 3L, 2L)))
    py_to_r(np$arange(1,25)$reshape(4L, 3L, 2L))
```    

```{r}
# py_to_r(np$reshape(np$arange(1, 25), c(4L, 3L, 2L)))
# py_to_r(np$arange(1,25)$reshape(4L, 3L, 2L))

identical(
    py_to_r(np$reshape(np$arange(1, 25), c(4L, 3L, 2L))),
    py_to_r(np$arange(1,25)$reshape(4L, 3L, 2L))
)
```

> This is how row-major looks in R printing.

```{r}
(y.py.rm <- py_to_r(x.py.rm))
```

> Let's generate the same array in R (row-major):

```{r}
m <- matrix(1:24, c(3 * 4, 2), byrow = TRUE)
(z.r.rm <- aperm(array(m, dim = c(3, 4, 2)), c(2, 1, 3)))
```

> Now, if both arrays are the same, the difference must be zero:

```{r}
y.py.rm - z.r.rm
```

```{r}
# This is another way of creating the R array as row-major
aperm(array(1:25, dim = c(2, 3, 4)), c(3, 2, 1))
```

```{r}
identical(
    aperm(array(matrix(1:24, c(3 * 4, 2), byrow = TRUE), 
                dim = c(3, 4, 2)), c(2, 1, 3)), 
    aperm(array(1:25, dim = c(2, 3, 4)), c(3, 2, 1))
)
```

```{r}
# decomposing all terms. using rev() function
x <- 1:24
nr <- 4; nc <- 3; ns <- 2
( X.rm <- aperm(array(x, dim = c(ns, nc, nr)), perm = rev(1:length(dim(X.rm)))) )

```


> since the way the array is constructed doesn't have much sense, let's build a function:

```{r}
# 1st iteration of r_row_major
r_row_major_1 <- function(x, dims) {
    aperm(array(x, dim = c(dims[3], dims[2], dims[1])), c(3, 2, 1))
}

r_row_major_1(1:25, c(4,3,2))
```


```{r}
# 2nd iteration of r_row_major
# This time we replace the explicit and manual make up of the perm vector
r_row_major_2 <- function(x, dims) {
    aperm(array(x, dim = c(dims[3], dims[2], dims[1])), 
          perm = rev(1:length(dim(X.rm))))
}


r_row_major_2(1:25, c(4,3,2))
```

```{r}
# 3rd iteration of r_row_major
# 
r_row_major_3 <- function(x, dims) {
    X <- array(x, dim = rev(dims))
    aperm(X, perm = rev(1:length(dim(X))))
}


r_row_major_3(1:25, c(4, 3, 2))
```

> Testing if r_row_major_3() works for 2-D:

```{r}
r_row_major_3 <- function(x, dims) {
    X <- array(x, dim = rev(dims))
    aperm(X, perm = rev(1:length(dim(X))))
}

np <- reticulate::import("numpy", convert = FALSE)
op <- reticulate::import("operator")

reticulate::r_to_py(r_row_major_3(1:25, c(4, 3 * 2)))
np$reshape(np$arange(1, 25), c(4L, 3L * 2L))

# these two expresions are identical
op$sub(reticulate::r_to_py(r_row_major_3(1:25, c(4, 3 * 2))),
       np$reshape(np$arange(1, 25), c(4L, 3L * 2L))
)
```

3-D

```{r}
r_row_major_3 <- function(x, dims) {
    X <- array(x, dim = rev(dims))
    aperm(X, perm = rev(1:length(dim(X))))
}

np <- reticulate::import("numpy", convert = FALSE)
op <- reticulate::import("operator")

reticulate::r_to_py(r_row_major_3(1:25, c(4, 3, 2)))
np$reshape(np$arange(1, 25), c(4L, 3L, 2L))

# these two expresions are identical
op$sub(reticulate::r_to_py(r_row_major_3(1:25, c(4, 3, 2))),
       np$reshape(np$arange(1, 25), c(4L, 3L, 2L))
)
```

> 4-D

```{r}
r_row_major_3 <- function(x, dims) {
    X <- array(x, dim = rev(dims))
    aperm(X, perm = rev(1:length(dim(X))))
}

np <- reticulate::import("numpy", convert = FALSE)
op <- reticulate::import("operator")

reticulate::r_to_py(r_row_major_3(1:25, c(4, 3, 2, 1)))
np$reshape(np$arange(1, 25), c(4L, 3L, 2L, 1L))

# these two expresions are identical
op$sub(reticulate::r_to_py(r_row_major_3(1:25, c(4, 3, 2, 1))),
       np$reshape(np$arange(1, 25), c(4L, 3L, 2L, 1L))
)
```


> 5-D

```{r}
np <- reticulate::import("numpy", convert = FALSE)
op <- reticulate::import("operator")

r_row_major <- function(x, dims) {
    X <- array(x, dim = rev(dims))
    aperm(X, perm = rev(1:length(dim(X))))
}

# using np$reshape(np$arange(1, 121), c(5L, 4L, 3L, 2L, 1L))
identical(
    array(0, c(5,4,3,2,1)),   # 5-D array of zeros
    op$sub(
        reticulate::r_to_py(r_row_major(1:121, c(5, 4, 3, 2, 1))), 
        np$reshape(np$arange(1, 121), c(5L, 4L, 3L, 2L, 1L))
    )
)
# [1] TRUE

# using np$arange(1, 121)$reshape(5L, 4L, 3L, 2L, 1L)
identical(
    array(0, c(5,4,3,2,1)),   # 5-D array of zeros
    op$sub(
        reticulate::r_to_py(r_row_major(1:121, c(5, 4, 3, 2, 1))), 
        np$arange(1, 121)$reshape(5L, 4L, 3L, 2L, 1L)
    )
)
# [1] TRUE

```

```{r}
r_row_major <- function(x, dims) {
    X <- array(x, dim = rev(dims))
    aperm(X, perm = rev(1:length(dim(X))))
}

array(1:25, c(4, 3, 2))        # column-major
r_row_major(1:25, c(4, 3, 2))  # row-major
```








```{r}
r_to_py(r_row_major(1:25, c(4,3,2)))
```


```{r}
o <- import("operator")
o$sub(x.py.rm, r_to_py(r_row_major(1:25, c(4,3,2))))
```


> This is another way to demonstrate row-major from R to Python, but it makes no sense from the the way it has been built in Python:
    
    np$reshape(np$arange(1, 25), c(4L, 3L, 2L))

```{r}
(r_to_py <- np$array(aperm(array(1:25, c(2,3,4)), c(3,2,1))))
```

> If these arrays are identical, the restult should be zero:

```{r}
o <- import("operator")
o$sub(x.py.rm, r_to_py)
```




